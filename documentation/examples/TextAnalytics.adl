//# -- overall 2313 lines of JSON reduced to 520 lines of ADL text. Zero loss of fidelity. 

//#-------------------------------------------------------------------------------- Operations

@location('{Endpoint}/text/analytics/v3.1-preview.3')
interface TextAnalytics {

  /// Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed.
  /// - parameters
  ///   - body: Collection of documents to analyze and tasks to execute
  @post('./analyze') 
  @LongRunning
  Analyze(@body body: AnalyzeBatchInput): LroResult<AnalyzeJobState>;

  /// Get the status of an analysis job.  A job may consist of one or more tasks.  
  /// Once all tasks are completed, the job will transition to the completed state and results will be available for each task
  /// - return 200: Analysis job status and metadata.
  @get('./analyze/jobs/{jobId}')
  AnalyzeStatus(AnalyzeJobId, ShowStats, Top, Skip): Result<AnalyzeJobState> || NotFound;

  /// Get details of the healthcare prediction job specified by the jobId.
  @get('./entities/health/jobs/{jobId}')
  HealthStatus(JobId,ShowStats,Top,Skip): Result<HealthcareJobState> || NotFound;

  /// Cancel healthcare prediction job.
  @delete('./entities/health/jobs/{jobId}') 
  @LongRunning
  CancelHealthJob(JobId): LroResult<true> || NotFound; /// the original spec doesn't describe the LRO target correctly.

  /// Start a healthcare analysis job to recognize healthcare related entities (drugs, conditions, symptoms, etc) and their relations.
  @post('./entities/health/jobs')
  @LongRunning
  Health(ModelVersion, StringIndexType, MultiLanguageInput) LroResult<???> || NotFound; /// the original spec doesn't describe the LRO target correctly.

  /// The API returns a list of general named entities in a given document. 
  /// For the list of supported entity types, check [Supported Entity Types in Text Analytics API](https://aka.ms/taner). 
  /// See the [Supported languages in Text Analytics API](https://aka.ms/talangs) for the list of enabled languages.
  /// - return 200: A successful call results in a list of recognized entities returned for each valid document.
  @post('./entities/recognition/general')
  EntitiesRecognitionGeneral(ModelVersion, ShowStats, StringIndexType, MultiLanguageInput) : Result<EntitiesResult>;
 
  /// The API returns a list of entities with personal information (\\\"SSN\\\", \\\"Bank Account\\\" etc) 
  /// in the document. For the list of supported entity types, check [Supported languages in Text Analytics API](https://aka.ms/tanerpii\">Supported Entity Types in Text Analytics API</a>. See the <a href=\"https://aka.ms/talangs) for the list of enabled languages.
  /// - parameter domain: (Optional) if specified, will set the PII domain to include only a subset of the entity categories. Possible values include: 'PHI', 'none'.
  /// - return 200: A successful call results in a list of entities containing personal information returned for each valid document
  @post('./entities/recognition/pii')
  EntitiesRecognitionPii(ModelVersion, ShowStats, StringIndexType, MultiLanguageInput, domain: @query @optional 'PHI'|'none' ): Result<PiiResult>;

  /// The API returns a list of recognized entities with links to a well-known knowledge base. See the [Supported languages in Text Analytics API](https://aka.ms/talangs) for the list of enabled languages.
  /// - return 200: A successful call results in a list of recognized entities with links to a well-known knowledge base returned for each valid document
  @post('./entities/linking')
  EntitiesLinking(ModelVersion, ShowStats, StringIndexType, MultiLanguageInput): Result<EntityLinkingResult>;

  /// The API returns a list of recognized entities with links to a well-known knowledge base. See the [Supported languages in Text Analytics API](https://aka.ms/talangs) for the list of enabled languages.
  /// - return 200: A successful response results in 0 or more key phrases identified in each valid document
  @post('./keyPhrases')
  KeyPhrases(ModelVersion, ShowStats,  MultiLanguageInput): Result<KeyPhraseResult>;

  /// The API returns the detected language and a numeric score between 0 and 1. Scores close to 1 indicate 100% certainty that the identified language is true. See the <a href=\"https://aka.ms/talangs\">Supported languages in Text Analytics API</a> for the list of enabled languages.
  /// - returns 200: 
  @post('./Languages')
  Languages(ModelVersion, ShowStats, LanguageInput) : Result<LanguageResult>;

  /// The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple levels of granularity, start from the a document level, down to sentence and key terms (aspects) and opinions.
  /// - parameter opinionMining: (Optional) if set to true, response will contain input and document level statistics including aspect-based sentiment analysis results.
  /// - return 200: A successful call results in a document sentiment prediction, as well as sentiment scores for each sentiment class (Positive, Negative, and Neutral)
  @post('./')
  Sentiment(ModelVersion, ShowStats, StringIndexType, MultiLanguageInput, opinionMining: @query @optional boolean ): Result<SentimentResponse>
}


//#-------------------------------------------------------------------------------- Responses 

response ErrorResult {
  /// Bad Request
  @statusCode(400)
  response BadRequest(content: @body ErrorResponse ) => throw content;

   /// Internal error response
  @statusCode(500)
  response InternalError(content: @body ErrorResponse ) => throw content;
}

/// Job ID Not Found
@statusCode(404)
response NotFound(content: @body ErrorResponse ) => throw content;

response Result<T> : ErrorResult {
  @statusCode(200)
  response Ok(content: @body T ) => content;
}

response LROResult<T> : Result<T> {
  /// A successful call results with an Operation-Location header used to check the status of the analysis job.
  @statusCode(202)
  response Accepted(operationLocation: @header('OperationLocation') string ) => operationLocation;
}


//#-------------------------------------------------------------------------------- Models
/// NOTES: 1500 lines of JSON models distilled down to 440 lines of text (including Enums, and not inlcluding extra line breaks)


model JobDescriptor {
  /// Optional display name for the analysis job.  
  displayName: string;
}

/// Contains a set of input documents to be analyzed by the service.
model MultiLanguageBatchInput {
  /// The set of documents to process as part of this batch.
  documents: Array<MultiLanguageInput>;
}

/// Contains an input document to be analyzed by the service.
model MultiLanguageInput {
  /// A unique, non-empty document identifier
  id: string;

  /// The input text to process.
  text: string;

  /// (Optional) This is the 2 letter ISO 639-1 representation of a language. For example, use \"en\" for English; \"es\" for Spanish etc. If not set, use \"en\" for English as default
  language: @optional string; 
}

model EntitiesTaskParameters {
  modelVersion: @optional @name('model-version') @default('latest') string;
  stringIndexType: @optional StringIndexType;
}

model EntitiesTask {
  parameters: @optional EntitiesTaskParameters;
}

model PiiTaskParameters {
  domain: "phi" | "none";
  modelVersion: @optional @name('model-version') @default('latest') string;
  stringIndexType: @optional StringIndexType;
}

model PiiTask {
  parameters: @optional PiiTaskParameters;
}

model KeyPhrasesTaskParameters {
   modelVersion: @optional @name('model-version') @default('latest') string;  
}

model KeyPhrasesTask {
  parameters: @optional KeyPhrasesTaskParameters;
}

model JobTasks {
    entityRecognitonTasks: @optional Array<EntitiesTask>;

    entityRecognitionPiiTasks: @optional Array<PiiTask>;

    keyPhraseExtractionTasks: @optional Array<KeyPhrasesTask>;
}

model JobManifest {
  /// The set of tasks to execute on the input documents. Cannot specify the same task more than once.
  tasks: JobTasks;
}

model AnalyzeBatchInput : JobDescriptor, JobManifest {
  analysisInput: MultiLanguageBatchInput;
}

model Pagination {
  nextlink: url;
}

model TaskState {
  name: string;
  status: State;
  lastUpdateDateTime: dateTime;
}

model JobMetadata {
  createdDateTime: dateTime;
  displayName: @optional string;
  expirationDateTime: @optional dateTime;
  jobId: uuid;
  lastUpdateDateTime: dateTime;
  status: State;
}

/// if showStats=true was specified in the request this field will contain information about the document payload
model DocumentStatistics {

  /// Number of text elements recognized in the document
  charactersCount: int32;

  /// Number of transactions for the document
  transactionsCount: int32;
}

model DocumentEntities {
  /// Unique, non-empty document identifier.
  id: string;

  /// Recognized entities in the document
  entities: Array<Entity>;

  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional  DocumentStatistics;
}

model DocumentError {
  /// Document ID
  id: string;

  /// Document Error
  error: TextAnalyticsError;
}

model EntitiesResult {
  /// Response by document
  documents: Array<DocumentEntities>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model EntityRecognitionTask : TaskState {
  results: EntitiesResult;
}

model TasksStateTasksDetails {
  details: @optional TaskState;
  completed: int32;
  failed: int32;
  inProgress: int32;
  total: int32;
  entityRecognitionTasks: Array<EntityRecognitionTask>;
}

model TasksStateTasks {
  details: TasksStateTasksDetails;
}

model TasksState {
  tasks: TasksStateTasks;
}

/// if showStats=true was specified in the request this field will contain information about the request payload
model RequestStatistics { 
  /// Number of documents submitted in the request.
  documentsCount: int32;

  /// Number of valid documents. This excludes empty, over-size limit or non-supported languages documents
  validDocumentsCount: int32;

  /// Number of invalid documents. This includes empty, over-size limit or non-supported languages documents
  erroneousDocumentsCount: int32;

  /// Number of transactions for the request
  transactionsCount: int64;
  
}

/// Represents the confidence scores between 0 and 1 across all sentiment classes: positive, neutral, negative
model SentimentConfidenceScorePerLabel {
  positive: double;
  neutral: double;
  negative: double;
}

model SentenceSentiment {
  /// The sentence text
  text: string;
  
  /// The predicted Sentiment for the sentence
  sentiment: SentenceSentimentValue;

  /// The sentiment confidence score between 0 and 1 for the sentence for all classes
  confidenceScores: SentimentConfidenceScorePerLabel;

  /// The sentence offset from the start of the document
  offset: int32;

  /// The length of the sentence
  length: int32;

  /// The array of aspect object for the sentence
  aspects: @optional Array<SentenceAspect>;

  /// The array of opinion object for the sentence.
  opinions: @optional Array<SentenceOpinion>;
}

model SentenceAspect {
  /// Aspect level sentiment for the aspect in the sentence
  sentiment: TokenSentimentValue;

  /// Aspect level sentiment confidence scores for the aspect in the sentence.
  confidenceScores: AspectConfidenceScoreLabel;
    
  /// The aspect offset from the start of the sentence
  offset: int32;

  /// The length of the aspect
  length: int32;

  /// The aspect text detected
  text: string;

  /// The array of either opinion or aspect object which is related to the aspect
  relations: Array<AspectRelation>;
}

model SentenceOpinion {
  /// Opinion level sentiment for the aspect in the sentence
  sentiment: TokenSentimentValue;

  /// Opinion level sentiment confidence scores for the aspect in the sentence.
  confidenceScores: AspectConfidenceScoreLabel;
    
  /// The aspect offset from the start of the sentence
  offset: int32;

  /// The length of the opinion
  length: int32;

  /// The aspect text detected
  text: string;

  /// The indicator representing if the opinion is negated.
  isNegated: boolean;
}

model AspectRelation {
  /// The type related to the aspect
  relationType: AspectRelationType;

  /// The JSON pointer indicating the linked object.
  ref: string;
}

/// Represents the confidence scores across all sentiment classes: positive, neutral, negative
model AspectConfidenceScoreLabel {
  positive: double;
  negative: double;
}
 
model PiiDocumentEntities {
  
  /// Unique, non-empty document identifier
  id: string;
  
  /// Returns redacted text.
  redactedText: string;
  
  /// Recognized entities in the document
  entities: Array<Entity>;
    
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>; 

  /// if showStats=true was specified in the request this field will contain information about the document payload
  statistics: @optional DocumentStatistics;
}

model AnalyzeJobState : JobMetadata, TasksState, Pagination {

  errors: Array<TextAnalyticsError>;

  statistics: RequestStatistics;
}

model Entity {
  
  /// Entity text as appears in the request
  text: string;

  /// Entity type 
  category: string;
  
  /// (Optional) Entity sub type 
  subcategory: @optional string;
  
  /// Start position for the entity text. Use of different 'stringIndexType' values can affect the offset returned 
  offset: int32;
  
  /// Length for the entity text. Use of different 'stringIndexType' values can affect the length returned 
  length: int32;
  
  /// Confidence score between 0 and 1 of the extracted entity 
  confidenceScore: double;
}

model EntityLinkingResult {
  /// Response by document
  documents: Array<DocumentLinkedEntities>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: string;
}

model DocumentLinkedEntities {
  /// Unique, non-empty document identifier
  id: string;

  /// Recognized well-known entities in the document
  entities: Array<LinkedEntity>;

  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional DocumentStatistics;
}

model HealthcareJobState: JobMetadata, Pagination {
  results: HealthcareResult;
  errors: Array<TextAnalyticsError>;
}

model HealthcareResult {
  /// Response by document
  documents: Array<DocumentHealthcareEntities>;
  errors: Array<DocumentError>;
  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring
  modelVersion: string;
}

model DocumentHealthcareEntities { 

  /// Unique, non-empty document identifier
  id: string;

  /// Healthcare entities
  entities: Array<HealthcareEntity>;
  
  /// Healthcare entity relations
  relations: Array<HealthcareRelation>;
  
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload
  statistics: @optional DocumentStatistics;
}

model HealthcareEntity : Entity{
  isNegated: boolean;

  /// Entity references in known data sources
  links: Array<HealthcareEntityLink>;
}

model HealthcareRelation {
  /// Type of relation. Examples include: `DosageOfMedication` or 'FrequencyOfMedication', etc
  relationType: string;
 
  /// If true the relation between the entities is bidirectional, otherwise directionality is source to target
  bidirectional: boolean;
 
  /// Reference link to the source entity
  source: string;
 
  /// Reference link to the target entity
  target: string;
 
}
 

model HealthcareEntityLink {
  /// Entity Catalog. Examples include: UMLS, CHV, MSH, etc.
  dataSource: string;

  /// Entity id in the given source catalog.
  id: string;

}

model LinkedEntity {
  /// Entity Linking formal name
  name: string;

  /// List of instances this entity appears in the text
  matches: Array<Match>;

  /// Language used in the data source
  language: string;

  /// Unique identifier of the recognized entity from the data source
  id: string;

  /// URL for the entity's page from the data source
  url: string;

  /// Data source used to extract entity linking, such as Wiki/Bing etc
  dataSource: string;

  /// Bing Entity Search API unique identifier of the recognized entity
  bingId: string;
}

model Match { 
  /// If a well-known item is recognized, a decimal number denoting the confidence level between 0 and 1 will be returned
  confidenceScore: double;
    
  /// Entity text as appears in the request
  text: string;
    
  /// Start position for the entity match text
  offset: int32;
    
  /// Length for the entity match text
  length: int32;
}

model KeyPhraseResult {
  /// Response by document
  documents: Array<DocumentKeyPhrases>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model DocumentKeyPhrases {
  /// Unique, non-empty document identifier
  id: string;
 
  /// A list of representative words or phrases. The number of key phrases returned is proportional to the number of words in the input document
  keyPhrases: Array<string>;
  
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional DocumentStatistics;
}

model LanguageBatchInput {
  documents: Array<LanguageInput>;
}

model LanguageInput {
  /// Unique, non-empty document identifier
  id: string;

  text: string;
  countryHint: @optional string;
}

model PiiResult {
  /// Response by document
  documents: Array<PiiDocumentEntities>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model LanguageResult {
  /// Response by document
  documents: Array<DocumentLanguage>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model DocumentLanguage {
  /// Unique, non-empty document identifier
  id: string;
 
  /// Detected Language
  detectedLanguage: detectedLanguage;
  
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional DocumentStatistics;
}

model DetectedLanguage {
  /// Long name of a detected language (e.g. English, French)
  name: string;

  /// A two letter representation of the detected language according to the ISO 639-1 standard (e.g. en, fr)
  iso6391Name: string;

  /// A confidence score between 0 and 1. Scores close to 1 indicate 100% certainty that the identified language is true
  confidenceScore: double;

}

//#-------------------------------------------------------------------------------- Enums
@sealed
enum State {
  notStarted: "NotStarted";
  running: "running";
  succeeded: "succeeded";
  failed: "failed";
  cancelled: "cancelled";
  cancelling: "cancelling";
  partiallyCompleted: "partiallyCompleted";
}

@sealed
enum StringIndexType {
  /// Returned offset and length values will correspond to TextElements (Graphemes and Grapheme clusters) confirming to the Unicode 8.0.0 standard. Use this option if your application is written in .Net Framework or .Net Core and you will be using StringInfo."
  TextElements_v8: "TextElements_v8";

  /// Returned offset and length values will correspond to Unicode code points. Use this option if your application is written in a language that support Unicode, for example Python.
  UnicodeCodePoint: "UnicodeCodePoint";
            
  /// Returned offset and length values will correspond to UTF-16 code units. Use this option if your application is written in a language that support Unicode, for example Java, JavaScript.
  Utf16CodeUnit: "Utf16CodeUnit";        
}

/// The predicted Sentiment for the sentence.
@sealed
enum SentenceSentimentValue {
  positive: "positive";
  neutral: "neutral";
  negative: "negative";
}

/// Aspect level sentiment for the aspect in the sentence.
@sealed
enum TokenSentimentValue {
  positive: "positive";
  mixed: "mixed";
  negative: "negative";
}  

@sealed 
enum AspectRelationType {
  opinion: "opinion";
  aspect: "aspect";
}
